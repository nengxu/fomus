;;; -*- mode: lisp; syntax: common-lisp; package: cl-user; base: 10 -*-

;;; The purpose of this file is helping people that do not want to install
;;; the iterate library

;;; !!! do not edit this file has been automatically generated from ads.lisp
;;;     whose terms and conditions equally apply for this file too

(defpackage :ads
  (:use :cl)
  (:export #:make-int-var-from-to #:make-int-var-domain
	   #:post #:ads
	   #:example
	   #:acc-nokey2
	   ))

(in-package :ads)

(setf *print-circle* t)	; for safety - not that i am really reading all this #1# stuff...

;;; var
(defstruct var
  domain constraints value (tabu 0)
  proj-cost		; caching the cost projection on this variable
  )

(defun var-set-randomly (var)
  (setf (var-value var)
	(nth (random (length (var-domain var))) (var-domain var))))

(defun var-compute-proj-cost (var)
  (let* ((list1 nil) (c nil) (result0 0))
    (block nil
      (tagbody
	 (setq list1 (var-constraints var))
       loop-top-nil
	 (if (atom list1) (go loop-end-nil))
	 (setq c (car list1))
	 (setq list1 (cdr list1))
	 (setq result0 (+ result0 (constraint-cost c)))
	 (go loop-top-nil)
       loop-end-nil)
      result0)))

(defun var-update-proj-cost (var)
  (setf (var-proj-cost var) (var-compute-proj-cost var)))

(defun make-int-var-from-to (from to)
  (make-var :domain (let* ((i nil)
			   (limit215 nil)
			   (result214 nil)
			   (end-pointer216 nil)
			   (temp217 nil))
		      (block nil
			(tagbody
			   (setq limit215 to)
			   (setq i (- from 1))
			 loop-top-nil
			   (setq i (+ i 1))
			   (if (> i limit215) (go loop-end-nil))
			   (progn
			     (setq temp217 (list i))
			     (setq end-pointer216
				   (if result214 (setf (cdr end-pointer216) temp217)
				       (setq result214 temp217)))
			     result214)
			   (go loop-top-nil)
			 loop-end-nil)
			result214))))

(defun make-int-var-domain (domain)
  (make-var :domain domain))

;;; constraint
(defstruct constraint
  vars costfn
  cost				    ; caching the actual computed cost
  )

(defun constraint-compute-cost (constraint)
  (apply (constraint-costfn constraint)
	 (constraint-vars constraint)))

(defun constraint-update-cost (constraint)
  (setf (constraint-cost constraint) (constraint-compute-cost constraint)))

(defun post (form &rest vars)
  (flet ((var-syms (num)
	   (let* ((i nil)
		  (limit219 nil)
		  (result218 nil)
		  (end-pointer220 nil)
		  (temp221 nil))
	     (block nil
	       (tagbody
		  (setq limit219 num)
		  (setq i 0)
		loop-top-nil
		  (setq i (+ i 1))
		  (if (> i limit219) (go loop-end-nil))
		  (progn
		    (setq temp221 (list (intern (format nil "v~a" i) "ads")))
		    (setq end-pointer220
			  (if result218 (setf (cdr end-pointer220) temp221)
			      (setq result218 temp221)))
		    result218)
		  (go loop-top-nil)
		loop-end-nil)
	       result218))))
    (let* ((var-syms (var-syms (length vars)))
	   (c (make-constraint
	       :vars vars
	       :costfn (compile nil
				`(lambda (,@var-syms)
				   (let (,@ (let* ((list223 nil)
						   (s nil)
						   (result222 nil)
						   (end-pointer224 nil)
						   (temp225 nil))
					      (block nil
						(tagbody
						   (setq list223 var-syms)
						 loop-top-nil
						   (if (atom list223) (go loop-end-nil))
						   (setq s (car list223))
						   (setq list223 (cdr list223))
						   (progn
						     (setq temp225 (list `(,s (var-value ,s))))
						     (setq end-pointer224
							   (if result222 (setf (cdr end-pointer224) temp225)
							       (setq result222 temp225)))
						     result222)
						   (go loop-top-nil)
						 loop-end-nil)
						result222)))
				     ,form))))))
      (dolist (v vars)
	(push c (var-constraints v)))
      c)))

;;; ads
(defun collect-constraints (vars)
  (let* ((list233 nil)
	 (v nil)
	 (result232 nil)
	 (end-pointer236 nil)
	 (temp237 nil))
    (block top
      (tagbody
	 (setq list233 vars)
       loop-top-top
	 (if (atom list233) (go loop-end-top))
	 (setq v (car list233))
	 (setq list233 (cdr list233))
	 (let* ((list235 nil) (c nil))
	   (block nil
	     (tagbody
		(setq list235 (var-constraints v))
	      loop-top-nil
		(if (atom list235) (go loop-end-nil))
		(setq c (car list235))
		(setq list235 (cdr list235))
		(progn
		  (when (not (member c result232 :test #'eql))
		    (setq temp237 (list c))
		    (setq end-pointer236
			  (if result232 (setf (cdr end-pointer236) temp237)
			      (setq result232 temp237))))
		  result232)
		(go loop-top-nil)
	      loop-end-nil)
	     nil))
	 (go loop-top-top)
       loop-end-top)
      result232)))

(defun print-info (vars global-cost)
  (terpri)
  (princ (list '***var-value
	       (let* ((list239 nil)
		      (v nil)
		      (result238 nil)
		      (end-pointer240 nil)
		      (temp241 nil))
		 (block nil
		   (tagbody
		      (setq list239 vars)
		    loop-top-nil
		      (if (atom list239) (go loop-end-nil))
		      (setq v (car list239))
		      (setq list239 (cdr list239))
		      (progn
			(setq temp241
			      (list
			       (if (zerop (var-tabu v)) (format nil " ~a" (var-value v))
				   (format nil "^~a" (var-value v)))))
			(setq end-pointer240
			      (if result238 (setf (cdr end-pointer240) temp241)
				  (setq result238 temp241)))
			result238)
		      (go loop-top-nil)
		    loop-end-nil)
		   result238))
	       'global-cost
	       global-cost
	       'proj-cost
	       (mapcar #'var-proj-cost vars))))

(defun consistency-check (vars constraints global-cost)
  (let* ((constraints-costs (let* ((list243 nil)
				   (c nil)
				   (result242 nil)
				   (end-pointer244 nil)
				   (temp245 nil))
			      (block nil
				(tagbody
				   (setq list243 constraints)
				 loop-top-nil
				   (if (atom list243) (go loop-end-nil))
				   (setq c (car list243))
				   (setq list243 (cdr list243))
				   (progn
				     (setq temp245 (list (constraint-compute-cost c)))
				     (setq end-pointer244
					   (if result242 (setf (cdr end-pointer244) temp245)
					       (setq result242 temp245)))
				     result242)
				   (go loop-top-nil)
				 loop-end-nil)
				result242)))
	 (gc (apply #'+ constraints-costs))
	 (vars-projs (let* ((list247 nil)
			    (var nil)
			    (result246 nil)
			    (end-pointer248 nil)
			    (temp251 nil))
		       (block nil
			 (tagbody
			    (setq list247 vars)
			  loop-top-nil
			    (if (atom list247) (go loop-end-nil))
			    (setq var (car list247))
			    (setq list247 (cdr list247))
			    (progn
			      (setq temp251
				    (list
				     (let* ((list250 nil) (c nil) (cost nil) (result249 0))
				       (block nil
					 (tagbody
					    (setq list250 (var-constraints var))
					  loop-top-nil
					    (if (atom list250) (go loop-end-nil))
					    (setq c (car list250))
					    (setq list250 (cdr list250))
					    (setq cost
						  (nth (position c constraints) constraints-costs))
					    (setq result249 (+ result249 cost))
					    (go loop-top-nil)
					  loop-end-nil)
					 result249))))
			      (setq end-pointer248
				    (if result246 (setf (cdr end-pointer248) temp251)
					(setq result246 temp251)))
			      result246)
			    (go loop-top-nil)
			  loop-end-nil)
			 result246))))
    (assert (= gc global-cost))
    (let* ((list253 nil) (c nil) (list254 nil) (cost nil))
      (block nil
	(tagbody
	   (setq list253 constraints)
	   (setq list254 constraints-costs)
	 loop-top-nil
	   (if (atom list253) (go loop-end-nil))
	   (setq c (car list253))
	   (setq list253 (cdr list253))
	   (if (atom list254) (go loop-end-nil))
	   (setq cost (car list254))
	   (setq list254 (cdr list254))
	   (block nil
	     (let ()
	       (tagbody
		  (go g3649)
		g3648
		  (tagbody
		     (sb-kernel:assert-error '(= (constraint-cost c) cost) 'nil nil))
		  (psetq)
		g3649
		  (if (not (= (constraint-cost c) cost)) (progn nil (go g3648))
		      nil)
		  (return-from nil))))
	   (go loop-top-nil)
	 loop-end-nil)
	nil))
    (let* ((list256 nil) (var nil) (list257 nil) (proj nil))
      (block nil
	(tagbody
	   (setq list256 vars)
	   (setq list257 vars-projs)
	 loop-top-nil
	   (if (atom list256) (go loop-end-nil))
	   (setq var (car list256))
	   (setq list256 (cdr list256))
	   (if (atom list257) (go loop-end-nil))
	   (setq proj (car list257))
	   (setq list257 (cdr list257))
	   (block nil
	     (let ()
	       (tagbody
		  (go g3651)
		g3650
		  (tagbody
		     (sb-kernel:assert-error '(= proj (var-proj-cost var)) 'nil nil))
		  (psetq)
		g3651
		  (if (not (= proj (var-proj-cost var))) (progn nil (go g3650))
		      nil)
		  (return-from nil))))
	   (go loop-top-nil)
	 loop-end-nil)
	nil))
    ))

(defun ads (vars &key
	    (tabu-tenure 3)
	    (max-iterations 20)		; later this will be 100000
	    (reset-limit (length vars)) ; number of tabu variables that will cause
	    (reset-percentage 100)) ; a percentage of those to be randomly reset
  (unless (= 100 reset-percentage)
    (warn "sorry, assuming (= 100 reset-percentage)"))
  (let ((constraints (collect-constraints vars)))
    ;; initial random config
    (dolist (v vars) (var-set-randomly v))    
    (dolist (c constraints) (constraint-update-cost c))
    (dolist (v vars) (var-update-proj-cost v))
    ;; the big search loop
    (let* ((best-sol nil)
	   (best-cost most-positive-fixnum)
	   (tabu-count 0)
	   (count279 nil)
	   (global-cost nil))
      (block nil
	(tagbody
	   (setq count279 max-iterations)
	 loop-top-nil
	   (if (<= count279 0) (go loop-end-nil))
	   (setq global-cost
		 (let* ((list281 nil) (c nil) (result280 0))
		   (block nil
		     (tagbody
			(setq list281 constraints)
		      loop-top-nil
			(if (atom list281) (go loop-end-nil))
			(setq c (car list281))
			(setq list281 (cdr list281))
			(setq result280 (+ result280 (constraint-cost c)))
			(go loop-top-nil)
		      loop-end-nil)
		     result280)))
	   (consistency-check vars constraints global-cost)
	   (if (zerop global-cost)
	       (progn
		 nil
		 (progn (setq best-cost 0) (setq best-sol (mapcar #'var-value vars)))
		 (go loop-end-nil))
	       nil)
	   (if (<= reset-limit tabu-count)
	       (progn
		 nil
		 (if (< global-cost best-cost)
		     (progn
		       nil
		       (progn
			 (setq best-cost global-cost)
			 (setq best-sol (mapcar #'var-value vars))))
		     nil)
		 (block nil
		   (let ((n-list3693 vars))
		     (tagbody
		      start3694
			(if (not (endp n-list3693))
			    (progn
			      nil
			      (let ((v (car n-list3693)))
				(setq n-list3693 (cdr n-list3693))
				(tagbody
				   (var-set-randomly v)
				   (let* ((g3696 v))
				     (multiple-value-bind
					   (g3695)
					 0
				       (funcall #'(setf var-tabu) g3695 g3696)))))
			      (go start3694))
			    nil)))
		   nil)
		 (setq tabu-count 0)
		 (block nil
		   (let ((n-list3697 constraints))
		     (tagbody
		      start3698
			(if (not (endp n-list3697))
			    (progn
			      nil
			      (let ((c (car n-list3697)))
				(setq n-list3697 (cdr n-list3697))
				(tagbody (constraint-update-cost c)))
			      (go start3698))
			    nil)))
		   nil)
		 (block nil
		   (let ((n-list3699 vars))
		     (tagbody
		      start3700
			(if (not (endp n-list3699))
			    (progn
			      nil
			      (let ((v (car n-list3699)))
				(setq n-list3699 (cdr n-list3699))
				(tagbody (var-update-proj-cost v)))
			      (go start3700))
			    nil)))
		   nil)
		 (setq global-cost
		       (let* ((list283 nil) (c nil) (result282 0))
			 (block nil
			   (tagbody
			      (setq list283 constraints)
			    loop-top-nil
			      (if (atom list283) (go loop-end-nil))
			      (setq c (car list283))
			      (setq list283 (cdr list283))
			      (setq result282 (+ result282 (constraint-cost c)))
			      (go loop-top-nil)
			    loop-end-nil)
			   result282)))
		 (consistency-check vars constraints global-cost))
	       nil)
	   (let ((worst-var
		  (let* ((list285 nil)
			 (v nil)
			 (temp286 nil)
			 (result284 nil)
			 (max287 nil)
			 (first-time288 t))
		    (block nil
		      (tagbody
			 (setq list285 vars)
		       loop-top-nil
			 (if (atom list285) (go loop-end-nil))
			 (setq v (car list285))
			 (setq list285 (cdr list285))
			 (if (< 1 (var-tabu v))
			     (progn
			       (let* ((g3702 v)
				      (g3703 1)
				      (g3701 (- (var-tabu g3702) g3703)))
				 (funcall #'(setf var-tabu) g3701 g3702)))
			     (if t
				 (progn
				   (if (= 1 (var-tabu v))
				       (progn
					 nil
					 (let* ((g3705 v)
						(g3706 1)
						(g3704
						 (- (var-tabu g3705) g3706)))
					   (funcall #'(setf var-tabu) g3704 g3705))
					 (let* ((g3708 1)
						(g3707 (- tabu-count g3708)))
					   (setq tabu-count g3707)))
				       nil)
				   (setq temp286 (var-proj-cost v))
				   (if first-time288
				       (progn
					 (setq first-time288 nil)
					 (setq max287 temp286)
					 (setq result284 v))
				       (if t
					   (progn
					     (if (> temp286 max287)
						 (progn
						   (setq max287 temp286)
						   (setq result284 v))
						 (if t (progn result284) nil)))
					   nil)))
				 nil))
			 (go loop-top-nil)
		       loop-end-nil)
		      result284))))
	     (if (not worst-var) (progn nil (error "no var is movable")) nil)
	     (let* ((old-value (var-value worst-var))
		    (list290 nil)
		    (possible-move nil)
		    (proj nil)
		    (temp291 nil)
		    (move-proj nil)
		    (min292 nil)
		    (first-time293 t))
	       (block nil
		 (tagbody
		    (setq list290 (var-domain worst-var))
		  loop-top-nil
		    (if (atom list290) (go loop-end-nil))
		    (setq possible-move (car list290))
		    (setq list290 (cdr list290))
		    (let* ((g3710 worst-var))
		      (multiple-value-bind
			    (g3709)
			  possible-move
			(funcall #'(setf var-value) g3709 g3710)))
		    (block nil
		      (let ((n-list3711 (var-constraints worst-var)))
			(tagbody
			 start3712
			   (if (not (endp n-list3711))
			       (progn
				 nil
				 (let ((c (car n-list3711)))
				   (setq n-list3711 (cdr n-list3711))
				   (tagbody (constraint-update-cost c)))
				 (go start3712))
			       nil)))
		      nil)
		    (setq proj (var-compute-proj-cost worst-var))
		    (setq temp291 proj)
		    (if first-time293
			(progn
			  (setq first-time293 nil)
			  (setq min292 temp291)
			  (setq move-proj (cons possible-move proj)))
			(if t
			    (progn
			      (if (< temp291 min292)
				  (progn
				    (setq min292 temp291)
				    (setq move-proj (cons possible-move proj)))
				  (if t (progn move-proj) nil)))
			    nil))
		    (go loop-top-nil)
		  loop-end-nil
		    (let ((whole3713 move-proj))
		      (let* ()
			(let ((args3715 whole3713))
			  (if (not (sb-int:list-of-length-at-least-p args3715 1))
			      (progn
				nil
				(sb-kernel::arg-count-error 'destructuring-bind 'nil
							    args3715
							    '(move &rest proj) 1 nil))
			      nil))
			(let* ((move (car whole3713)) (proj (cdr whole3713)))
			  (if (< proj (var-proj-cost worst-var))
			      (progn
				(progn
				  (let* ((g3717 worst-var))
				    (multiple-value-bind
					  (g3716)
					move
				      (funcall #'(setf var-value) g3716 g3717)))
				  (let* ((g3719 worst-var))
				    (multiple-value-bind
					  (g3718)
					proj
				      (funcall #'(setf var-proj-cost) g3718
					       g3719)))
				  (let* ((g3721 worst-var))
				    (multiple-value-bind
					  (g3720)
					2
				      (funcall #'(setf var-tabu) g3720 g3721))))
				(let* ((g3723 1) (g3722 (+ tabu-count g3723)))
				  (setq tabu-count g3722)))
			      (if t
				  (progn
				    (progn
				      (let* ((g3725 worst-var))
					(multiple-value-bind
					      (g3724)
					    old-value
					  (funcall #'(setf var-value) g3724
						   g3725)))
				      (let* ((g3727 worst-var))
					(multiple-value-bind
					      (g3726)
					    tabu-tenure
					  (funcall #'(setf var-tabu) g3726
						   g3727))))
				    (let* ((g3729 1)
					   (g3728 (+ tabu-count g3729)))
				      (setq tabu-count g3728)))
				  nil)))))
		    (let* ((list295 nil)
			   (c nil)
			   (dirty-vars nil)
			   (end-pointer296 nil)
			   (temp297 nil))
		      (block nil
			(tagbody
			   (setq list295 (var-constraints worst-var))
			 loop-top-nil
			   (if (atom list295) (go loop-end-nil))
			   (setq c (car list295))
			   (setq list295 (cdr list295))
			   (constraint-update-cost c)
			   (block nil
			     (let ((n-list3730 (constraint-vars c)))
			       (tagbody
				start3731
				  (if (not (endp n-list3730))
				      (progn
					nil
					(let ((v (car n-list3730)))
					  (setq n-list3730 (cdr n-list3730))
					  (tagbody
					     (progn
					       (if (not (member v dirty-vars :test #'eql))
						   (progn
						     nil
						     (setq temp297 (list v))
						     (setq end-pointer296
							   (if dirty-vars
							       (sb-kernel:%rplacd
								end-pointer296
								temp297)
							       (setq dirty-vars
								     temp297))))
						   nil)
					       dirty-vars)))
					(go start3731))
				      nil)))
			     nil)
			   (go loop-top-nil)
			 loop-end-nil
			   (mapc #'var-update-proj-cost dirty-vars))
			nil)))
		 nil)))
	   (setq count279 (1- count279))
	   (go loop-top-nil)
	 loop-end-nil
	   (when best-sol
	     (let* ((list345 nil) (v nil) (list346 nil) (x nil))
	       (block nil
		 (tagbody
		    (setq list345 vars)
		    (setq list346 best-sol)
		  loop-top-nil
		    (if (atom list345) (go loop-end-nil))
		    (setq v (car list345))
		    (setq list345 (cdr list345))
		    (if (atom list346) (go loop-end-nil))
		    (setq x (car list346))
		    (setq list346 (cdr list346))
		    (let* ((g3750 v))
		      (multiple-value-bind
			    (g3749)
			  x
			(funcall #'(setf var-value) g3749 g3750)))
		    (go loop-top-nil)
		  loop-end-nil)
		 nil))
	     )
	   (dolist (c constraints) (constraint-update-cost c))
	   (dolist (v vars) (var-update-proj-cost v))
	   (setq global-cost
		 (let* ((list348 nil) (c nil) (result347 0))
		   (block nil
		     (tagbody
			(setq list348 constraints)
		      loop-top-nil
			(if (atom list348) (go loop-end-nil))
			(setq c (car list348))
			(setq list348 (cdr list348))
			(setq result347 (+ result347 (constraint-cost c)))
			(go loop-top-nil)
		      loop-end-nil)
		     result347))
		 )
	   (consistency-check vars constraints global-cost)
	   (return (values (mapcar #'var-value vars) global-cost)))
	nil))))

(defun example ()
  (let ((l (list (make-int-var-from-to 1 5)
		 (make-int-var-from-to 1 5)
		 (make-int-var-from-to 1 5))))
    ;; smallest distance as possible
    ;; between first and second
    (post
     '(abs (- v1 v2))
     (first l) (second l))
    ;; biggest distance as possible
    ;; between second and third
    (post
     '(max (- 10 (abs (- v1 v2))) 0)
     (second l) (third l))
    ;; the entire sum should
    ;; be greater than 10
    (post
     '(let ((sum (+ v1 v2 v3)))
       (if (< 10 sum)
	   0
	   (- 10 sum)))
     (first l) (second l) (third l))
    (ads l)))
;; the optimal sol is (5 5 1), 6
;; which is already reached sometimes

(defun cartesian-prod (list1 list2)
  (let* ((list299 nil)
	 (e1 nil)
	 (result298 nil)
	 (end-pointer302 nil)
	 (temp303 nil))
    (block top
      (tagbody
	 (setq list299 list1)
       loop-top-top
	 (if (atom list299) (go loop-end-top))
	 (setq e1 (car list299))
	 (setq list299 (cdr list299))
	 (let* ((list301 nil) (e2 nil))
	   (block nil
	     (tagbody
		(setq list301 list2)
	      loop-top-nil
		(if (atom list301) (go loop-end-nil))
		(setq e2 (car list301))
		(setq list301 (cdr list301))
		(progn
		  (setq temp303 (list (list e1 e2)))
		  (setq end-pointer302
			(if result298 (setf (cdr end-pointer302) temp303)
			    (setq result298 temp303)))
		  result298)
		(go loop-top-nil)
	      loop-end-nil)
	     nil))
	 (go loop-top-top)
       loop-end-top)
      result298))
  )

(defun acc-nokey2 (evs)
  (let* ((midis (mapcar #'fm:event-note evs))
	 (domain-data (let* ((list305 nil)
			     (m nil)
			     (result304 nil)
			     (end-pointer306 nil)
			     (temp311 nil))
			(block nil
			  (tagbody
			     (setq list305 midis)
			   loop-top-nil
			     (if (atom list305) (go loop-end-nil))
			     (setq m (car list305))
			     (setq list305 (cdr list305))
			     (progn
			       (setq temp311
				     (list
				      (let* ((list308 nil)
					     (acc nil)
					     (white-note nil)
					     (result307 nil)
					     (end-pointer309 nil)
					     (temp310 nil))
					(block nil
					  (tagbody
					     (setq list308 '(0 -1 1))
					   loop-top-nil
					     (if (atom list308) (go loop-end-nil))
					     (setq acc (car list308))
					     (setq list308 (cdr list308))
					     (setq white-note (fomus::notespelling m acc))
					     (if white-note
						 (progn
						   nil
						   (progn
						     (setq temp310 (list (list m white-note acc)))
						     (setq end-pointer309
							   (if result307
							       (sb-kernel:%rplacd end-pointer309
										  temp310)
							       (setq result307 temp310)))
						     result307))
						 nil)
					     (go loop-top-nil)
					   loop-end-nil)
					  result307))))
			       (setq end-pointer306
				     (if result304 (setf (cdr end-pointer306) temp311)
					 (setq result304 temp311)))
			       result304)
			     (go loop-top-nil)
			   loop-end-nil)
			  result304))
	   )
	 (vars (let* ((list313 nil)
		      (d nil)
		      (result312 nil)
		      (end-pointer314 nil)
		      (temp315 nil))
		 (block nil
		   (tagbody
		      (setq list313 domain-data)
		    loop-top-nil
		      (if (atom list313) (go loop-end-nil))
		      (setq d (car list313))
		      (setq list313 (cdr list313))
		      (progn
			(setq temp315 (list (make-int-var-from-to 0 (1- (length d)))))
			(setq end-pointer314
			      (if result312 (setf (cdr end-pointer314) temp315)
				  (setq result312 temp315)))
			result312)
		      (go loop-top-nil)
		    loop-end-nil)
		   result312))))
    ;; (print domain-data)
    ;;     (print vars)
    ;; constraint ivs
    (let* ((list317 nil)
	   (a nil)
	   (list318 nil)
	   (b nil)
	   (list319 nil)
	   (adata nil)
	   (list320 nil)
	   (bdata nil)
	   (cart nil)
	   (costs nil))
      (block nil
	(tagbody
	   (setq list317 vars)
	   (setq list318 (cdr vars))
	   (setq list319 domain-data)
	   (setq list320 (cdr domain-data))
	 loop-top-nil
	   (if (atom list317) (go loop-end-nil))
	   (setq a (car list317))
	   (setq list317 (cdr list317))
	   (if (atom list318) (go loop-end-nil))
	   (setq b (car list318))
	   (setq list318 (cdr list318))
	   (if (atom list319) (go loop-end-nil))
	   (setq adata (car list319))
	   (setq list319 (cdr list319))
	   (if (atom list320) (go loop-end-nil))
	   (setq bdata (car list320))
	   (setq list320 (cdr list320))
	   (setq cart (cartesian-prod (var-domain a) (var-domain b)))
	   (setq costs
		 (coerce
		  (let* ((list322 nil)
			 (b-ind nil)
			 (bd nil)
			 (result321 nil)
			 (end-pointer325 nil)
			 (temp326 nil))
		    (block top
		      (tagbody
			 (setq list322 (var-domain b))
		       loop-top-top
			 (if (atom list322) (go loop-end-top))
			 (setq b-ind (car list322))
			 (setq list322 (cdr list322))
			 (setq bd (nth b-ind bdata))
			 (let* ((list324 nil)
				(a-ind nil)
				(ad nil)
				(iv-value nil)
				(iv-quality nil)
				(cost nil))
			   (block nil
			     (tagbody
				(setq list324 (var-domain a))
			      loop-top-nil
				(if (atom list324) (go loop-end-nil))
				(setq a-ind (car list324))
				(setq list324 (cdr list324))
				(setq ad (nth a-ind adata))
				(multiple-value-setq (iv-value iv-quality)
				  (fomus::interval (first ad) (third ad) (first bd)
						   (third bd)))
				(setq cost
				      (let ((g3736 iv-quality))
					(declare (ignorable g3736))
					(if
					 (or (eql g3736 '-2) (eql g3736 '2))
					 (progn
					   nil
					   (if (= -2 iv-quality)
					       (let ((g3737 iv-value))
						 (declare (ignorable g3737))
						 (if (eql g3737 '4) (progn nil 0)
						     (if t (progn nil 1) nil)))
					       (let ((g3738 iv-value))
						 (declare (ignorable g3738))
						 (if (eql g3738 '3) (progn nil 0)
						     (if t (progn nil 1) nil)))))
					 (if
					  (or (eql g3736 '-3) (eql g3736 '3))
					  (progn nil 20)
					  (if t (progn nil 0) nil)))))
				(progn
				  (setq temp326 (list cost))
				  (setq end-pointer325
					(if result321
					    (sb-kernel:%rplacd end-pointer325
							       temp326)
					    (setq result321 temp326)))
				  result321)
				(go loop-top-nil)
			      loop-end-nil)
			     nil))
			 (go loop-top-top)
		       loop-end-top)
		      result321))
		  'vector))
	   (post `(svref ,costs (+ v1 (* ,(length (var-domain a)) v2))) a b)
	   (go loop-top-nil)
	 loop-end-nil)
	nil))
    
    ;; constrain individual pitches
    (let* ((list328 nil) (v nil) (list329 nil) (data nil) (cost nil))
      (block nil
	(tagbody
	   (setq list328 vars)
	   (setq list329 domain-data)
	 loop-top-nil
	   (if (atom list328) (go loop-end-nil))
	   (setq v (car list328))
	   (setq list328 (cdr list328))
	   (if (atom list329) (go loop-end-nil))
	   (setq data (car list329))
	   (setq list329 (cdr list329))
	   (setq cost
		 (coerce
		  (let* ((list331 nil)
			 (m nil)
			 (wn nil)
			 (acc nil)
			 (result330 nil)
			 (end-pointer332 nil)
			 (temp333 nil))
		    (block nil
		      (tagbody
			 (setq list331 data)
		       loop-top-nil
			 (if (atom list331) (go loop-end-nil))
			 (let ((dsetq3741 (car list331)))
			   (setq m (car dsetq3741))
			   (setq wn (car (cdr dsetq3741)))
			   (setq acc (car (cdr (cdr dsetq3741))))
			   dsetq3741)
			 (setq list331 (cdr list331))
			 (progn
			   (setq temp333
				 (list
				  (if (and (= wn 6) (= acc 1)) (progn 5)
				      (if (and (= wn 0) (= acc -1)) (progn 5)
					  (if (and (= wn 3) (= acc -1)) (progn 5)
					      (if t (progn 0) nil))))))
			   (setq end-pointer332
				 (if result330
				     (sb-kernel:%rplacd end-pointer332
							temp333)
				     (setq result330 temp333)))
			   result330)
			 (go loop-top-nil)
		       loop-end-nil)
		      result330))
		  'vector))
	   (post `(svref ,cost v1) v)
	   (go loop-top-nil)
	 loop-end-nil)
	nil))
    (multiple-value-bind (inds cost)
	(ads vars
	     :tabu-tenure 5
	     :max-iterations 30000
	     :reset-limit 5)
      (print (list 'cost cost))      
      (let* ((list335 nil)
	     (ind nil)
	     (list336 nil)
	     (data nil)
	     (entry nil)
	     (list337 nil)
	     (ev nil)
	     (list338 nil)
	     (proj nil))
	(block nil
	  (tagbody
	     (setq list335 inds)
	     (setq list336 domain-data)
	     (setq list337 evs)
	     (setq list338 (mapcar #'var-proj-cost vars))
	   loop-top-nil
	     (if (atom list335) (go loop-end-nil))
	     (setq ind (car list335))
	     (setq list335 (cdr list335))
	     (if (atom list336) (go loop-end-nil))
	     (setq data (car list336))
	     (setq list336 (cdr list336))
	     (setq entry (nth ind data))
	     (if (atom list337) (go loop-end-nil))
	     (setq ev (car list337))
	     (setq list337 (cdr list337))
	     (if (atom list338) (go loop-end-nil))
	     (setq proj (car list338))
	     (setq list338 (cdr list338))
	     (let* ((g3745 ev))
	       (multiple-value-bind
		     (g3744)
		   (cons (first entry) (third entry))
		 (funcall #'(setf fomus:event-note) g3744 g3745)))
	     (if (not (zerop proj))
		 (progn
		   nil
		   (let* ((g3748 `(:text ,(princ-to-string proj)))
			  (g3747 ev)
			  (g3746 (cons g3748 (fomus:event-marks g3747))))
		     (funcall #'(setf fomus:event-marks) g3746 g3747)))
		 nil)
	     (go loop-top-nil)
	   loop-end-nil)
	  nil)))
    evs))

